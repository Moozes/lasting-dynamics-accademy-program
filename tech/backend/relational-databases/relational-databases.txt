Check these links for a refresher on relational databases
    relational databases    https://dev.to/louaiboumediene/mastering-relational-database-design-a-comprehensive-guide-3jh8
    relational databases    https://hackernoon.com/the-system-design-cheat-sheet-relational-databases-part-1
    database design         https://support.microsoft.com/en-us/office/database-design-basics-eb2159cf-1e30-401a-8084-bd4f9c9ca1f5
        information gathering
        deside on tables
        deside on columns
        deside on relations
        fill with mock data and test and  refine
        the last step applying the normal forms (1,2,3,4,5)
        1NF, 2NF, 3NF are good enough for most databases
        normal forms help you test and validate if the structure of the dabase is good
    system design           https://www.designgurus.io/blog/system-design-cheat-sheet
        data
        storage
        distributed systems
        networking and communications
        ...etc

Postgresql reference links
    I mention these links because the docs are a bit messy and not easy to browse
    SQL language https://www.postgresql.org/docs/current/sql.html
        definitions, types, function & operators...etc
    SQL commands api refernece  https://www.postgresql.org/docs/current/sql-commands.html
        CREATE TABLE
        DROP TABLE
        ALTER
        ...etc

Database
    A database is a structured collection of data that is organized and stored in a way that facilitates efficient retrieval, manipulation, and management
Relational database 
    A relational database is a type of database that organizes data into tables (relations) with rows (records) and columns (fields). These tables are interconnected through relationships, allowing data to be accessed and combined in various ways.
RDBMS
    MySQL, PostgreSQL, Oracle, and Microsoft SQL Server...etc
SQL (Structured Query Language)
    the standard language used to interact with relational dabases
    this is the base syntaxe that exists on all RDBMS's but each RDBMS may add additional stuff, like complexe types, other querying methods, statistical methods...etc

Terms
    Table: A collection of related data organized in rows and columns.
    Row: A single instance or entry in a table (also known as a record or tuple).
    Column: A specific characteristic or property of the data in a table (also known as a field or attribute).
    Primary Key: A column or combination of columns that uniquely identifies each row in a table.
    Foreign Key: A column or combination of columns that references the primary key of another table, establishing a relationship between the two tables.
    Join: An operation that combines rows from two or more tables based on a related column.
    Index: A data structure that improves the performance of data retrieval operations by creating a sorted representation of the data in a table.
    View: A virtual table that is dynamically generated from one or more underlying tables.
    Stored Procedure: A pre-compiled collection of SQL statements that can be executed as a single unit.
    Trigger: A special type of stored procedure that is automatically executed when a specific event occurs in a table, such as an INSERT, UPDATE, or DELETE statement.

Primary keys are usually indexed by default
Look up Table
    A lookup table, also known as a reference table or a code table, is a table that contains predefined sets of values that can be used to populate columns in other tables
    just like an Enum in programming
Superkey and Candidate Key
    A superkey is a set of one or more columns in a table that uniquely identifies each record. A candidate key is a minimal superkey, meaning it contains no unnecessary columns. In other words, a candidate key is a superkey with the minimal number of columns required to uniquely identify each record.
Primary Key and Alternate Key
    A primary key is a candidate key chosen as the main unique identifier for a table. An alternate key, also known as a unique key, is any other candidate key that could have been chosen as the primary key but was not.
Surrogate Key and Natural Key
    A surrogate key is an artificial key (often a sequential number or a GUID) that is used as the primary key in a table. It has no inherent meaning or relationship to the data itself. A natural key, on the other hand, is a key derived from the data itself, such as an employee ID or a product code.
    Surrogate Key is mostly used.
Simple Key, Composite Key, Compound Key
    A simple key is a single column used as a primary key or a foreign key.
    A composite key is a combination of two or more columns used as a primary key or a foreign key.
    A compound key is a combination of two or more simple keys used as a 
    
Relationsships
    one-to-one: the foreign key can be in either the tables
    one-to-many: the foreign key must be in the many side
    many-to-many: we will need an assiciative/junction talbe to hold both primary keys

Parent Tables and Child Tables
    the table on the many side is called child
    the table on the one side is called the parent
    the child holds the foreign key

Entity Relationship Modeling
    diagram conventions to designing and drawing databases

Normalization
    First normal form 1NF
        rule: each cell in the table should contain a single value, not a set of values
        example: 
            (first_name, last_name) instead of (full_name)
            (phone, email) instead of (contact_info)
        purpose: 
            1NF exists to make databases actually workable with standard database operations. Without it, you can't use SQL properly
            Can't Query Properly
            Can't Sort/Group Reliably
            Can't Enforce Data Integrity
            Indexing Problems Database can't create efficient indexes on multi-value fields.
    Second normal form 2NF
        rule: requires that each non-key column be fully dependent on the entire primary key, not on just part of the key. This rule applies when you have a primary key that consists of more than one column.
        explanation: 
                   /---primary key---\
            Table (order_id, product_id, product_name)
            if i give you product_id only will you be able to determin product_name. Yes, so this is a violation of the rule
        purpose: 
            Storage Waste (Redundancy)
            Update Anomalies
            Insert Anomalies
            Delete Anomalies
    Third normal form 3NF
        rule: requires that not only every non-key column be dependent on the entire primary key, but that non-key columns be independent of each other
        explanation
                    /-PK-\
            Table (order_id, product_id, product_name)
            if i give you product_id only will you be able to determin product_name. Yes, so this is a violation of the rule, a non primary key field determins another non primary key field
        purpose: 
            3NF exists to eliminate the same problems as 2NF, but for a different type of dependency - when non-key columns depend on each other instead of the primary key.

Joins
    Table students
    Table departments
    Table professors

    Relation students many-to-one departments
    Relation professors many-to-many departments

    INNER JOIN
        only returns rows with matching values from both tables
        example query: give me all students and their departments
    LEFT JOIN
        returns all rows of the left table plus matching rows from the right table
        example query: give me all students and their departments, even students without departments
    RIGHT JOIN
        returns all rows of the right table plus matching rows from the left table
        rarely used, because you can just make switch between right and left table and use LEFT JOIN instead
    FULL JOIN
        returns all rows of both tables
        example query: give me all students and departments, even students without departments and departments without students

Constraints 
    There are multiple constraints but not that much
    - Check Constraints
    - Not-Null Constraints
    - Unique Constraints 
        note unique allows for one NULL value :)
    - Primary Keys
    - Foreign Keys 
        You cant create an employee with organization_id that does not exist on the Organization table
        you can add also ON DELETE and ON UPDATE with these actions (NO ACTION, RESTRICT, CASCADE, SET NULL , SET DEFAULT)
    - Exclusion Constraints 
        kind of not intuitive

Relational database design patterns
    Techniques used in designing relational databases that solves specific problems and chieve specific goals, each one with its pros and cons
    Normalization 
        we already talked about this above
    Denormalization 
        is adding redundant data to a normalized database to improve query performance, simplify the database structure, or address issues with read-heavy database applications requiring fast data access.
    Entity-Attribute-Value (EAV)
        for flexible attributes without modifying schema, similar to NoSQL but using relational databases
    Master-Detail
        for example Employee one-to-one EmployeeDetails 
    Table Inheritance
                 -- TemporaryEmployee
        Employee |
                 -- PermanentEmployee
    Star
        We have a central facts table that contains quantitative metrics, used for analytics
    Snowflake
        Similar to start but surrounding tables are normalized
    Audit logging
        We have log tables that stores information about data updates or actions performed in the application (emplyee updated, deleted...etc)
    Versioning
        storing different versions of the data, 
        for example if employee was updated we dont update its record directly 
        we create a new record with the new data and mark it as version 2
        this was just an example and there are multiple ways to implement versioning


Scaling and Fault Tolerance
    scaling
        Vertical Scaling (Scaling Up): Add more resources (e.g., CPU, RAM)
        Horizontal Scaling (Scaling Out): Entails distributing the database load across multiple servers

    Fault tolerance in case of hardware/software failure
        Replication
        Clustering
        Backup and Recovery

    strategies for scaling and fault tolrance
        Master-Slave (Primary-Secondary) replication
        Multi-Master (Master-Master, Primary-Primary ) replication
        Sharding
        Federation


Designing a relational database
    What is good database design?
        There are 2 principles
        1- duplicate information (also called redundant data) is bad, because it wastes space and increases the likelihood of errors and inconsistencies
        2- The second principle is that the correctness and completeness of information is important. incorrect info => incorrect reports => incorrect decisions

    1-Determining the purpose of your database
        example: The customer database keeps a list of customer information for the purpose of producing mailings and reports.
    2-Finding and organizing the required information 
        seperate information into major subjects
        students (name, age, sex...)
        departments (speciality, modules...)
        professors(...)
        administration workers(...)
    3-Dividing the information into tables
        students table, departments table, professors table
        NOTE: This might seem intuitive to translate major subjects into tables, but suppose we are building an app that only manages study program, we do not care about administration workers for example, in this case we will not create a table for administration workers and we might add some information about them in the departments table only 
    4-Turning information items into columns
        students(first_name, last_name, age, sex...)
        departments (speciality, module name, module coefficient...)
        professors(...)
        NOTE: this also might seem easy, but we need to think about this, im i going to query students by their full name only, im i going to order professors by their last name, we need to devide information into its smallest form so it is easy to query, update, delete, or else we will be performing some tricky string operations, another good example storing the address as single string or deviding it into (country, region, city, street) columns
    5-Specifying primary keys
        a single column or multiple columns
        surrogate key or natural key
        usually surrogate key (a serial number with no meaning or relation to the data it self)
    6-Creating the table relationships
        students many-to-one departments
        professors many-to-many departments
        ...etc
        NOTE: ask your self, im i going to need data about students and their departments, when i delete a department what will happen to students belonging to it, can i create a department without students...etc
    7-Refining the design
        Create a mock database with your current desing
        fill it with data
        test it, query stuff, update stuff, delete stuff
        you will discover 
            some missing columns
            duplicate information, that can be calculated instead of stored as a seperate column
            some columns might need to be devided into more atomic values for querying purposes
            ...etc
    8-Applying the normalization rules
        Normalization does not tell you what you need need in your database, but lets you know if your design is correct and coherent
        you can apply the level that you need, because the more you normalize the more complexe the schema will be, and the more complexe the querying will be